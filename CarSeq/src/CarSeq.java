import java.io.*;
import java.util.Formatter;
import java.util.Scanner;

public class CarSeq {
	static PrintWriter out;
	static Formatter s = new Formatter();
	static int[][] carPosition;
	static int[][] link;
	static int[][] OpPosition;
	static int[][] capConstrain;
	public static void main(String[] args) throws IOException {
		int nCars = 10;
		int nOp = 5;
		int nClass = 6;
		int[] demandOfCar = new int[] { 1, 1, 2, 2, 2, 2 }; // for each car, the
															// number required.
		link = new int[][] { { 1, 0, 1, 1, 0 }, { 0, 0, 0, 1, 0 },
				{ 0, 1, 0, 0, 1 }, { 0, 1, 0, 1, 0 }, { 1, 0, 1, 0, 0 },
				{ 1, 1, 0, 0, 0 } };
		capConstrain= new int[][] {{1,2,1,2,1},{2,3,3,5,5}};
		carPosition = new int[nCars][nClass]; // C i,k k class car is at
		// position i .
		int[][] carPositionF = new int[nClass][nCars];
		OpPosition = new int[nCars][nOp]; // O i,l l option is at
											// position i
		int[][] OpPositionF = new int[nOp][nCars]; // , l in Operation demand.
		int n = 1;
		for (int i = 0; i < carPosition.length; i++) {// 遍历纵向的数据
			for (int j = 0; j < carPosition[i].length; j++) {// 遍历横向的数据
				carPosition[i][j] = n++;
			}
		}
		for (int i = 0; i < carPosition.length; i++) {// 遍历纵向的数据
			for (int j = 0; j < carPosition[i].length; j++) {// 遍历横向的数据
				carPositionF[j][i] = carPosition[i][j];
			}
		}
		n = 0;
		for (int i = 0; i < OpPosition.length; i++) {// 遍历纵向的数据
			for (int j = 0; j < OpPosition[i].length; j++) {// 遍历横向的数据
				OpPosition[i][j] = 100 + n++;
			}
		}
		for (int i = 0; i < OpPosition.length; i++) {// 遍历纵向的数据
			for (int j = 0; j < OpPosition[i].length; j++) {// 遍历横向的数据
				OpPositionF[j][i] = OpPosition[i][j];
			}
		}
		out = new PrintWriter(new FileWriter("car-seq" + ".cnf"));

	//	s.format("c Pidgeon Formula Autogenerated \n");
	//	s.format("c Author: Jianshen HE \n");
		// p cnf variables clauses
		// s.format("p cnf %s %s %n",(n*(n+1)),((n+1)+nCr(n,2)*(n+1)+nCr(n+1,2)*n));
		// sum of k class cars is equal to demandOfCar[k]

							for(int i=0;i<nCars;i++)        //limit one car per position
							limitSum(carPosition[i],1);
							linkOperation();
		
		
		// deman!!!!!! to sat the each car number! sum carPosition[i][5]=2

							for (int i = 0; i < demandOfCar.length; i++)  //demand constrain 
						     limitSum(carPositionF[i], demandOfCar[i]);

		/*
		 * for (int i = 0; i < nCars - 2; i++) { int[] oneLine = new int[3];
		 * int[] tempA = new int[2]; getSarray(OpPositionF[0], oneLine, i, 3);
		 * 
		 * combine2(oneLine, 3, 2, tempA, 2);
		 * 
		 * }
		 */
		for(int i=0; i<nOp;i++)
		 subAtmost(OpPositionF[i], capConstrain[0][i]+1, capConstrain[1][i]+1);    //cap constrain

		
		
		System.out.println("Pidgeon problem CNF file for n = " + " generated.");
		out.print(s);
		out.close();
	}

	static void combine1(int a[], int n, int m, int b[], final int M)

	{
		for (int i = n; i >= m; i--) {
			b[m - 1] = i - 1;
			if (m > 1)
				combine1(a, i - 1, m - 1, b, M);
			else {

				for (int j = M - 1; j >= 0; j--)
					s.format(a[b[j]] + " ");
				s.format("0 \n");
			}
		}
	}

	static void combine2(int a[], int n, int m, int b[], final int M)

	{
		for (int i = n; i >= m; i--) {
			b[m - 1] = i - 1;
			if (m > 1)
				combine2(a, i - 1, m - 1, b, M);
			else {

				for (int j = M - 1; j >= 0; j--)
					s.format("-" + a[b[j]] + " ");
				s.format("0 \n");
			}
		}
	}

	static void getSarray(int a[], int b[], int s, int n) {
		int i = 0;
		while (n != 0) {

			b[i] = a[s];
			s++;
			i++;
			n--;
		}
	}

	static void limitSum(int a[], int n) {
		// at most
		int[] temp = new int[n + 1];
		combine2(a, a.length, n + 1, temp, n + 1);
		// at least
		int[] temp2 = new int[a.length - n + 1];
		combine1(a, a.length, a.length - n + 1, temp2, a.length - n + 1);
	}

	static void limitMose(int a[], int n) {
		int[] temp = new int[n + 1];
		combine2(a, a.length, n + 1, temp, n + 1);
	}

	static void subAtmost(int a[], int n, int m) {

		for (int i = 0; i < a.length - m + 1; i++) {
			int[] oneLine = new int[m];
			int[] tempA = new int[n];
			getSarray(a, oneLine, i, m);

			combine2(oneLine, m, n, tempA, n);

		}

	}

	static void linkOperation() {
		for (int i = 0; i < carPosition.length; i++) {// 遍历纵向的数据
			for (int j = 0; j < carPosition[i].length; j++) {// 遍历横向的数据
				s.format("-" + carPosition[i][j] + " ");
				for (int p = 0; p < link[j].length; p++) {
					if (link[j][p] == 1)
						s.format(OpPosition[i][p] + " ");
					else
						s.format("-" + OpPosition[i][p] + " ");

				}
				s.format("0 \n");
			}
		}
	}
}

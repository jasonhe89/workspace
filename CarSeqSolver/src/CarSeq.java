import java.io.*;
import java.util.Formatter;
import java.util.Scanner;

public class CarSeq {
	static PrintWriter out;
	static Formatter s = new Formatter();
	static int[][] carPosition;
	static int[][] link;
	static int[][] OpPosition;
	static int[][] capConstrain;
	static int[] demandOfCar;
	static int nCars ;
	static int nOp;
	static int nClass;
	static int[][]  rawArray;
	public static void main(String[] args) throws IOException {
		
		 try {
	        	BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
	        	
	            System.out.print("Please enter sudoku puzzle file name: ");
	            String filename = read.readLine();
	            
	            Scanner scanner = new Scanner(new File(filename));
	            System.out.println("Read in:");
	            nCars= scanner.nextInt();
	            nOp=scanner.nextInt();
	            nClass=scanner.nextInt();
	            capConstrain= new int[2][nOp];
	            for(int k=0;k<2;k++)
	            for(int i=0;i<nOp;i++)
	            {
	            	capConstrain[k][i]=scanner.nextInt();
	            	
	            }
	            rawArray = new int[nClass][nOp+2];
	          for (int i = 0; i < rawArray.length; i++) {
	  			for (int j = 0; j < rawArray[i].length; j++)
	            	rawArray[i][j]=scanner.nextInt();
	          }
	          System.out.println("Read in:");
	          for (int i = 0; i < rawArray.length; i++) {
		  			for (int j = 0; j < rawArray[i].length; j++)
		            	System.out.print(rawArray[i][j]);
		  			System.out.println();
		          }
	          scanner.close();
	        }
		 catch(Exception ex){
	            ex.printStackTrace();
	        }
			 
		 
		//int nCars = 10;
	//	int nOp = 5;
	//	int nClass = 6;
		//demandOfCar = new int[] { 1, 1, 2, 2, 2, 2 }; // for each car, the
															// number required.
		 demandOfCar = new int[nClass];
		 	for(int i=0; i<nClass;i++)
		 	{
		 		demandOfCar[i]= rawArray[i][1];
		 		
		 	}
		//link = new int[][] { { 1, 0, 1, 1, 0 }, { 0, 0, 0, 1, 0 },
		//		{ 0, 1, 0, 0, 1 }, { 0, 1, 0, 1, 0 }, { 1, 0, 1, 0, 0 },
		//		{ 1, 1, 0, 0, 0 } };
		link = new int[nClass][nOp];
		for(int i=0; i<nClass;i++)
			for(int j=0; j<nOp;j++)
			{
				link[i][j]=rawArray[i][j+2];
			}
	//	capConstrain= new int[][] {{1,2,1,2,1},{2,3,3,5,5}};
		carPosition = new int[nCars][nClass]; // C i,k k class car is at
		// position i .
		int[][] carPositionF = new int[nClass][nCars];
		OpPosition = new int[nCars][nOp]; // O i,l l option is at
											// position i
		int[][] OpPositionF = new int[nOp][nCars]; // , l in Operation demand.
		int n = 1;
		for (int i = 0; i < carPosition.length; i++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
			for (int j = 0; j < carPosition[i].length; j++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
				carPosition[i][j] = n++;
			}
		}
		for (int i = 0; i < carPosition.length; i++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
			for (int j = 0; j < carPosition[i].length; j++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
				carPositionF[j][i] = carPosition[i][j];
			}
		}
		n = 1;
		for (int i = 0; i < OpPosition.length; i++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
			for (int j = 0; j < OpPosition[i].length; j++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
				OpPosition[i][j] = 100 + n++;
			}
		}
		for (int i = 0; i < OpPosition.length; i++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
			for (int j = 0; j < OpPosition[i].length; j++) {// 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
				OpPositionF[j][i] = OpPosition[i][j];
			}
		}
		out = new PrintWriter(new FileWriter("car-seq" + ".cnf"));

	//	s.format("c Pidgeon Formula Autogenerated \n");
	//	s.format("c Author: Jianshen HE \n");
		// p cnf variables clauses
		// s.format("p cnf %s %s %n",(n*(n+1)),((n+1)+nCr(n,2)*(n+1)+nCr(n+1,2)*n));
		// sum of k class cars is equal to demandOfCar[k]

						for(int i=0;i<nCars;i++)        //limit one car per position
						limitSum(carPosition[i],1);
					linkOperation();
					out.print(s);
					s= new Formatter();
						
		// deman!!!!!! to sat the each car number! sum carPosition[i][5]=2
					for(int i=0; i<nOp;i++)
						subAtmost(OpPositionF[i], capConstrain[0][i]+1, capConstrain[1][i]);    //cap constrain
				
							for (int i = 0; i < demandOfCar.length; i++)  //demand constrain 
							
						{	
								
							limitSum(carPositionF[0], demandOfCar[0]);
						
							}
		/*
		 * for (int i = 0; i < nCars - 2; i++) { int[] oneLine = new int[3];
		 * int[] tempA = new int[2]; getSarray(OpPositionF[0], oneLine, i, 3);
		 * 
		 * combine2(oneLine, 3, 2, tempA, 2);
		 * 
		 * }
		 */
						

		
		
		System.out.println("Pidgeon problem CNF file for n = " + " generated.");
		out.print(s);
		out.close();
	}

	static void combine1(int a[], int n, int m, int b[], final int M)

	{
		for (int i = n; i >= m; i--) {
			b[m - 1] = i - 1;
			if (m > 1)
				combine1(a, i - 1, m - 1, b, M);
			else {

				for (int j = M - 1; j >= 0; j--)
					s.format(a[b[j]] + " ");
				s.format("0 \n");
			}
			out.print(s);
			s= new Formatter();
		}
	}

	static void combine2(int a[], int n, int m, int b[], final int M)

	{
		for (int i = n; i >= m; i--) {
			b[m - 1] = i - 1;
			if (m > 1)
				combine2(a, i - 1, m - 1, b, M);
			else {

				for (int j = M - 1; j >= 0; j--)
					s.format("-%d ",a[b[j]]);
				s.format("0 \n");
			}
			out.print(s);
			s= new Formatter();
		}
	}

	static void getSarray(int a[], int b[], int s, int n) {
		int i = 0;
		while (n != 0) {

			b[i] = a[s];
			s++;
			i++;
			n--;
		}
	}

	static void limitSum(int a[], int n) {
		// at most
		int[] temp = new int[n + 1];
		combine2(a, a.length, n + 1, temp, n + 1);
		// at least
		int[] temp2 = new int[a.length - n + 1];
		combine1(a, a.length, a.length - n + 1, temp2, a.length - n + 1);
	}

	static void limitMose(int a[], int n) {
		int[] temp = new int[n + 1];
		combine2(a, a.length, n + 1, temp, n + 1);
	}

	static void subAtmost(int a[], int n, int m) {

		for (int i = 0; i < a.length - m + 1; i++) {
			int[] oneLine = new int[m];
			int[] tempA = new int[n];
			getSarray(a, oneLine, i, m);

			combine2(oneLine, m, n, tempA, n);

		}

	}

	static void linkOperation() {
		for (int i = 0; i < carPosition.length; i++) {
			for (int j = 0; j < carPosition[i].length; j++) {
				
				for (int p = 0; p < link[j].length; p++) {
					if (link[j][p] == 1){
						s.format("-" + carPosition[i][j] + " ");
						s.format(OpPosition[i][p] + " ");
						s.format("0 \n");
					}
					else
					{	s.format("-" + carPosition[i][j] + " ");
						s.format("-" + OpPosition[i][p] + " ");
						s.format("0 \n");
					}
				}
				
			}
		}
	}
	
	
}
